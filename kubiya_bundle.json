{
  "tools": [
    {
      "name": "say_hello",
      "source": null,
      "alias": null,
      "description": "Prints hello {name}!",
      "type": "docker",
      "content": "\npip install argparse > /dev/null 2>&1\npip install requests > /dev/null 2>&1\npython /tmp/main.py \"{{ .name }}\"\n",
      "content_url": null,
      "args": [
        {
          "name": "name",
          "type": null,
          "description": "name to say hello to",
          "required": true,
          "default": null,
          "options": null,
          "options_from": null
        }
      ],
      "env": [],
      "secrets": [],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/main.py",
          "content": "import argparse\nimport sys\nimport matplotlib.pyplot as plt\n\nimport requests\nimport pandas as pd\nimport slack_sdk\nimport os\n\ndef hello_world(name: str):\n    print(f\"Hello, {name}!\")\n\n\ndef filter_namespace_data(data):\n    \"\"\"\n    Filters the input data for all namespaces found in the structure and retains specified fields.\n\n    Parameters:\n    - data: The input data containing metrics for various namespaces.\n    - fields: List of fields to keep in the output.\n\n    Returns:\n    - JSON structure with the filtered data.\n    \"\"\"\n    # fields = [\"cpuEfficiency\", \"ramEfficiency\", \"totalEfficiency\", \"cpuCost\", \"ramCost\", \"totalCost\"]\n    fields = [\"cpuEfficiency\", \"ramEfficiency\", \"totalEfficiency\", \"totalCost\"]\n\n    result = {\n        namespace: {field: metrics.get(field) for field in fields}\n        for namespace, metrics in data[0].items() if metrics.get(\"properties\", {}).get(\"namespace\")\n    }\n    return result\n\n\ndef print_pandas_table(data):\n    \"\"\"\n    Prints the input data as a pandas DataFrame.\n\n    Parameters:\n    - data: The input data to print as a pandas DataFrame.\n    \"\"\"\n\n    df = pd.DataFrame(data).T\n    df.head()\n\n\ndef slack_result_image_to_slack(data):\n    \"\"\"\n    Sends a result image to a Slack channel.\n\n    Parameters:\n    - image_url (str): URL of the image to send to Slack\n    - slack_token (str): Slack API token\n    - slack_channel (str): Slack channel to send the image to\n    \"\"\"\n    df = pd.DataFrame(data).T\n\n    # Create a figure and axis\n    fig, ax = plt.subplots(figsize=(6, 10))  # Adjust figure size as needed\n    ax.axis('off')  # Hide the axes\n\n    # Create a table with matplotlib\n    table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center')\n    table.scale(1, 1.5)  # Adjust the scale of the table\n\n    # Save the table as an image\n    plt.savefig(\"dataframe_matplotlib.png\")\n\n    slack_token = os.getenv(\"SLACK_API_TOKEN\")\n\n    client = slack_sdk.WebClient(token=slack_token)\n\n    try:\n        response = client.files_upload(\n            channels=\"D05T1HF3MNZ\",\n            file='./dataframe_matplotlib.png',\n            initial_comment=\"Here is the detailed stats of the namespaces.\"\n        )\n    except Exception as e:\n        print(f\"Failed to send image to Slack: {e}\")\n        sys.exit(1)\n\n    if not response[\"ok\"]:\n        print(f\"Failed to send image to Slack: {response['error']}\")\n\n\ndef prettier_data(data):\n    \"\"\"\n\n    :param data:\n    :return:\n    \"\"\"\n\n    result = {}\n    for namespace, metrics in data:\n\n        cpu_efficiency = metrics['cpuEfficiency'] * 100\n        ram_efficiency = metrics['ramEfficiency'] * 100\n        total_efficiency = metrics['totalEfficiency'] * 100\n\n        result[namespace] = {\n            \"cpuEfficiency\": f\"{cpu_efficiency:.2f}%\",\n            \"ramEfficiency\": f\"{ram_efficiency:.2f}%\",\n            \"totalEfficiency\": f\"{total_efficiency:.2f}%\",\n            \"totalCost\": f\"${metrics['totalCost']:.2f}\"\n        }\n    return result\n\n\ndef query_prometheus(timeout='30s'):\n    \"\"\"\n    Queries Prometheus for a given metric.\n\n    Parameters:\n    - prometheus_url (str): Base URL of Prometheus server (e.g., 'http://localhost:9090')\n    - query (str): PromQL query to send to Prometheus\n    - timeout (str): Query timeout, e.g., '30s' (default is '30s')\n\n    Returns:\n    - JSON response from Prometheus with the query results\n    \"\"\"\n\n    cost_metrics_url = \"http://opencost.opencost:9090/model/allocation/compute\"\n    params = {'window': '7d', 'aggregate': 'namespace', 'includeIdle': 'true', 'step': '1d', 'accumulate': 'true'}\n\n    try:\n        response = requests.get(cost_metrics_url, params=params)\n        response.raise_for_status()  # Raise an error for failed requests\n        data = response.json()\n        if data['status'] == 'success':\n            structured_data = filter_namespace_data(data['data'])\n            sorted_data = sorted(structured_data.items(), key=lambda item: item[1]['totalCost'], reverse=True)\n            pretty_data = prettier_data(sorted_data)\n            slack_result_image_to_slack(pretty_data)\n            return pretty_data\n        else:\n            raise Exception(f\"Query failed with status: {data['status']}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"An error occurred: {e}\")\n        return None\n\n\nif __name__ == \"__main__\":\n\n    slack_token = os.getenv(\"SLACK_API_TOKEN\")\n    if not slack_token:\n        print(\"Slack API token found\")\n        sys.exit(1)\n\n    print(\"slack_token\", slack_token)\n\n    prometheus_query_results = query_prometheus()\n    print(\"Highest cost namespaces:\", prometheus_query_results)\n"
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.12",
      "long_running": false,
      "on_start": null,
      "on_build": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"say_hello\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n        Param0(\"name (Required)<br/>name to say hello to\"):::paramClass\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/>pip install argparse > /dev/null 2>&1<br/>pip install...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.12\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    },
    {
      "name": "namespaces_highest_cost",
      "source": null,
      "alias": null,
      "description": "Query for highest cost kubernetes namespaces",
      "type": "docker",
      "content": "\npip install argparse > /dev/null 2>&1\npip install requests > /dev/null 2>&1\npip install pandas > /dev/null 2>&1\npip install slack-sdk==3.11.0 > /dev/null 2>&1\npip install matplotlib > /dev/null 2>&1\npython /tmp/main.py\n",
      "content_url": null,
      "args": [],
      "env": [],
      "secrets": [
        "SLACK_API_TOKEN"
      ],
      "dependencies": null,
      "dependencies_url": null,
      "openapi": null,
      "with_files": [
        {
          "source": null,
          "destination": "/tmp/main.py",
          "content": "import argparse\nimport sys\nimport matplotlib.pyplot as plt\n\nimport requests\nimport pandas as pd\nimport slack_sdk\nimport os\n\ndef hello_world(name: str):\n    print(f\"Hello, {name}!\")\n\n\ndef filter_namespace_data(data):\n    \"\"\"\n    Filters the input data for all namespaces found in the structure and retains specified fields.\n\n    Parameters:\n    - data: The input data containing metrics for various namespaces.\n    - fields: List of fields to keep in the output.\n\n    Returns:\n    - JSON structure with the filtered data.\n    \"\"\"\n    # fields = [\"cpuEfficiency\", \"ramEfficiency\", \"totalEfficiency\", \"cpuCost\", \"ramCost\", \"totalCost\"]\n    fields = [\"cpuEfficiency\", \"ramEfficiency\", \"totalEfficiency\", \"totalCost\"]\n\n    result = {\n        namespace: {field: metrics.get(field) for field in fields}\n        for namespace, metrics in data[0].items() if metrics.get(\"properties\", {}).get(\"namespace\")\n    }\n    return result\n\n\ndef print_pandas_table(data):\n    \"\"\"\n    Prints the input data as a pandas DataFrame.\n\n    Parameters:\n    - data: The input data to print as a pandas DataFrame.\n    \"\"\"\n\n    df = pd.DataFrame(data).T\n    df.head()\n\n\ndef slack_result_image_to_slack(data):\n    \"\"\"\n    Sends a result image to a Slack channel.\n\n    Parameters:\n    - image_url (str): URL of the image to send to Slack\n    - slack_token (str): Slack API token\n    - slack_channel (str): Slack channel to send the image to\n    \"\"\"\n    df = pd.DataFrame(data).T\n\n    # Create a figure and axis\n    fig, ax = plt.subplots(figsize=(6, 10))  # Adjust figure size as needed\n    ax.axis('off')  # Hide the axes\n\n    # Create a table with matplotlib\n    table = ax.table(cellText=df.values, colLabels=df.columns, cellLoc='center', loc='center')\n    table.scale(1, 1.5)  # Adjust the scale of the table\n\n    # Save the table as an image\n    plt.savefig(\"dataframe_matplotlib.png\")\n\n    slack_token = os.getenv(\"SLACK_API_TOKEN\")\n\n    client = slack_sdk.WebClient(token=slack_token)\n\n    try:\n        response = client.files_upload(\n            channels=\"D05T1HF3MNZ\",\n            file='./dataframe_matplotlib.png',\n            initial_comment=\"Here is the detailed stats of the namespaces.\"\n        )\n    except Exception as e:\n        print(f\"Failed to send image to Slack: {e}\")\n        sys.exit(1)\n\n    if not response[\"ok\"]:\n        print(f\"Failed to send image to Slack: {response['error']}\")\n\n\ndef prettier_data(data):\n    \"\"\"\n\n    :param data:\n    :return:\n    \"\"\"\n\n    result = {}\n    for namespace, metrics in data:\n\n        cpu_efficiency = metrics['cpuEfficiency'] * 100\n        ram_efficiency = metrics['ramEfficiency'] * 100\n        total_efficiency = metrics['totalEfficiency'] * 100\n\n        result[namespace] = {\n            \"cpuEfficiency\": f\"{cpu_efficiency:.2f}%\",\n            \"ramEfficiency\": f\"{ram_efficiency:.2f}%\",\n            \"totalEfficiency\": f\"{total_efficiency:.2f}%\",\n            \"totalCost\": f\"${metrics['totalCost']:.2f}\"\n        }\n    return result\n\n\ndef query_prometheus(timeout='30s'):\n    \"\"\"\n    Queries Prometheus for a given metric.\n\n    Parameters:\n    - prometheus_url (str): Base URL of Prometheus server (e.g., 'http://localhost:9090')\n    - query (str): PromQL query to send to Prometheus\n    - timeout (str): Query timeout, e.g., '30s' (default is '30s')\n\n    Returns:\n    - JSON response from Prometheus with the query results\n    \"\"\"\n\n    cost_metrics_url = \"http://opencost.opencost:9090/model/allocation/compute\"\n    params = {'window': '7d', 'aggregate': 'namespace', 'includeIdle': 'true', 'step': '1d', 'accumulate': 'true'}\n\n    try:\n        response = requests.get(cost_metrics_url, params=params)\n        response.raise_for_status()  # Raise an error for failed requests\n        data = response.json()\n        if data['status'] == 'success':\n            structured_data = filter_namespace_data(data['data'])\n            sorted_data = sorted(structured_data.items(), key=lambda item: item[1]['totalCost'], reverse=True)\n            pretty_data = prettier_data(sorted_data)\n            slack_result_image_to_slack(pretty_data)\n            return pretty_data\n        else:\n            raise Exception(f\"Query failed with status: {data['status']}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"An error occurred: {e}\")\n        return None\n\n\nif __name__ == \"__main__\":\n\n    slack_token = os.getenv(\"SLACK_API_TOKEN\")\n    if not slack_token:\n        print(\"Slack API token found\")\n        sys.exit(1)\n\n    print(\"slack_token\", slack_token)\n\n    prometheus_query_results = query_prometheus()\n    print(\"Highest cost namespaces:\", prometheus_query_results)\n"
        }
      ],
      "with_services": [],
      "with_git_repo": null,
      "with_volumes": [],
      "entrypoint": [],
      "icon_url": null,
      "image": "python:3.11",
      "long_running": false,
      "on_start": null,
      "on_build": null,
      "on_complete": null,
      "mermaid": "graph TD\n    %% Styles\n    classDef triggerClass fill:#3498db,color:#fff,stroke:#2980b9,stroke-width:2px,font-weight:bold\n    classDef paramClass fill:#2ecc71,color:#fff,stroke:#27ae60,stroke-width:2px\n    classDef execClass fill:#e74c3c,color:#fff,stroke:#c0392b,stroke-width:2px,font-weight:bold\n    classDef envClass fill:#f39c12,color:#fff,stroke:#f1c40f,stroke-width:2px\n\n    %% Main Components\n    Trigger(\"Trigger\"):::triggerClass\n    Params(\"Parameters\"):::paramClass\n    Exec(\"namespaces_highest_cost\"):::execClass\n    Env(\"Environment\"):::envClass\n\n    %% Flow\n    Trigger --> Params --> Exec\n    Env --> Exec\n\n    %% Trigger Options\n    User(\"User\")\n    API(\"API\")\n    Webhook(\"Webhook\")\n    Cron(\"Scheduled\")\n    User --> Trigger\n    API --> Trigger\n    Webhook --> Trigger\n    Cron --> Trigger\n\n    %% Parameters\n    subgraph Parameters[\"Parameters\"]\n        direction TB\n    end\n    Parameters --- Params\n\n    %% Execution\n    subgraph Execution[\"Execution\"]\n        direction TB\n        Code(\"Script: <br/>pip install argparse > /dev/null 2>&1<br/>pip install...\")\n        Type(\"Type: Docker\")\n        Image(\"Docker Image: python:3.11\")\n    end\n    Execution --- Exec\n\n    %% Environment\n    subgraph Environment[\"Environment\"]\n        direction TB\n        Secrets(\"Secrets:<br/>SLACK_API_TOKEN\"):::envClass\n    end\n    Environment --- Env\n\n    %% Context Note\n    ContextNote(\"Parameter values can be<br/>fetched from context<br/>based on the trigger\")\n    ContextNote -.-> Params",
      "workflow": false,
      "metadata": {}
    }
  ],
  "errors": [],
  "python_bundle_version": "3.11.10"
}